# 1章：テストの目的と障壁
## テストを書く目的
- 事業信頼のため
- 安全なコードを維持するため
→リファクタリングを行っても実装済みの機能を逐一テストすることで影響範囲を確認することができる
→積極的なリファクタリングを推し進めることができる
- 実証品質の担保
→テストを書くことでテストが書きずらいコンポーネントを発見できる
→テストが書きづらい＝処理が多すぎるコンポーネント
- テキストドキュメントとしてのテスト
→レビュアーはテストを読むことで仕様を容易に把握することができる

# 2章：テスト手法とテスト戦略
## テストの範囲による分類
- 静的解析
→ TypscriptやESLintによる解析
→ 各モジュール内部の検証、モジュール間連携の不整合を検証

- 単体テスト
→ モジュール単体が提供する機能に着目したテスト
→ 稼働時には滅多に発生しないケース（コーナーケース）の検証に向いている

- 結合テスト
→ ロジックを担う関数〜UIコンポーネント〜APIクライアントまでといった「モジュールを繋げることで提供できる機能」に着目したテスト
→範囲は広いが、相対的にざっくりしたテストになる傾向がある

- E2Eテスト
→全てを通してヘッドレスブラウザ＋UIオートメーションで実施するテスト

## テストの目的による分類
- 機能テスト
→開発対象の機能に不具合がないかを検証
→フロントエンドにおける機能の大部分＝UIコンポーネントの操作(インタラクション)
→本物のブラウザAPIを使用するのが重要なテストのば場合、ヘッドレスブラウザ＋UIオートメーションを使用することが多い
- 非機能テスト
→「アクセシビリティテスト」：特に心身特性に隔たりのないプロダクト化を賢所するのが
- ホワイトボックステスト
- リグレッションテスト：特定時点から前後の差分を検出して、想定外の不具合が発生していないかを検証するテスト

## テスト範囲の深掘り
- 静的解析
→TypeScriptやESLintを導入することで可能

- 単体テスト
→定められた入力値から期待する出力値が得られるかをテストする
→UIコンポーネントで言うと、入力値（＝Props）出力値（＝HTMLのブロック）

→モジュールによっては滅多に派生しないケース（コーナーケース）に限り処理を中断した方がいい場合もある
→こういった点の洗い出しに単体テストは強い

- 結合テスト
```
①セレクトボックスを操作
②URL検索クエリーが変化
③検索クエリの変化によりデータ取得のAPIが叩かれる
④一覧の表示内容が更新
```
①を実行したら④が実行されるのを見るのが結合テスト。
①〜②の範囲のテストも結合テストと言える

- E2Eテスト
→UIテストに加え、外部ストレージやサブシステムを含むテスト（End to End）

## テストの目的の深掘り
- 機能テスト
→フロントエンドにおいてインタラクションテストが機能テストそのものになる

→ブラウザをヘッドレスモードで起動し、UIオートメーションで実施するテストが思い浮かぶが
→Reactなどで実装されたコンポーネントにはブラウザなしでテストできる環境が整っている
（スクロールやセッションストレージが絡む機能など一部ブラウザのみでしかテストできないものもある）

- 非機能テスト(=アクセシビリティテスト)
→「キーボードでチェックボックスをチェックできるか」や「視認性に問題ないコントラスト非になっているか」という検証項目ではそれぞれ的するツールが異なる

- ビジュアルリグレッションテスト
→CSSはコンポーネントに定義されたスタイルだけでなく、ブラウザで読み込まれたCSSからも影響を受ける
→ヘッドレスブラウザに描画された内容をキャプチャ・比較することでリグレッションが発生していないかを検証
→ユーザー操作前後などの比較も可能

## テスト戦略モデル
- アイスクリームコーン型
→アンチパターン
→運用コストが高く、不安定

- テストピラミッド
→下層のテストを多く書くことで、より安定した費用対効果の高いテスト戦略になる
（ブラウザを含む上層のテストは実行時間のコストが高い）

- テスティングトロフィー型
→結合テストに重点を置いた戦略   
→フロントエンドが提供する機能は、ユーザー操作を起点に提供されるため、ユーザー操作を起点とする結合テストにリソースを注ぐことがより良いテスト戦略になるという意図が込められている
